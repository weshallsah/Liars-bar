/**
 * Inco Network Types and Utilities for Solana
 *
 * This file provides TypeScript types and utilities for working with
 * Inco's confidential computing features on Solana.
 *
 * @see https://docs.inco.org/svm/home - Inco Solana Documentation
 */

import { BN } from "@coral-xyz/anchor";
import { PublicKey } from "@solana/web3.js";

// ============================================================================
// ENCRYPTED TYPES
// ============================================================================

/**
 * Euint128 - Encrypted unsigned 128-bit integer
 *
 * This type represents an encrypted value generated by Inco's TEE.
 * The value cannot be read directly - it must be decrypted using
 * attested decryption with proper authorization.
 *
 * Generated on-chain by:
 * - `e_rand()` - Encrypted random number generation
 * - `e_add()`, `e_sub()`, etc. - Encrypted arithmetic operations
 * - `encrypt()` - Encrypting plaintext values
 */
export interface Euint128 {
  /** The encrypted value stored as a u128 (represented as BN in JS) */
  0: BN;
}

/**
 * Card type with encrypted shape and value
 * Used in the Liar's Bar game for hidden card information
 */
export interface EncryptedCard {
  /** Encrypted card shape (e.g., hearts, diamonds, clubs, spades) */
  shape: Euint128;
  /** Encrypted card value (e.g., 1-13 for Ace-King) */
  value: Euint128;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Convert an Euint128 to a hex string handle for decryption
 *
 * @param euint - The encrypted Euint128 value
 * @returns Hex string handle (32 characters, zero-padded)
 *
 * @example
 * ```typescript
 * const tableData = await program.account.liarsTable.fetch(tablePda);
 * const handle = euint128ToHandle(tableData.randomSeed);
 * const decrypted = await decryptRandomValue(handle);
 * ```
 */
export function euint128ToHandle(euint: Euint128): string {
  return euint[0].toString("hex").padStart(32, "0");
}

/**
 * Convert a hex handle back to Euint128 format
 *
 * @param handle - The hex string handle
 * @returns Euint128 object
 */
export function handleToEuint128(handle: string): Euint128 {
  return { 0: new BN(handle, "hex") };
}

/**
 * Check if a value is a valid Euint128
 */
export function isEuint128(value: unknown): value is Euint128 {
  return (
    typeof value === "object" &&
    value !== null &&
    "0" in value &&
    BN.isBN((value as Euint128)[0])
  );
}

/**
 * Create a zero Euint128 (useful for initialization)
 */
export function zeroEuint128(): Euint128 {
  return { 0: new BN(0) };
}

// ============================================================================
// OPERATION TYPES
// ============================================================================

/**
 * Operand type for Inco operations
 * - 0: Encrypted handle
 * - 1: Plaintext value
 */
export type OperandType = 0 | 1;

/**
 * Inco operation types available via CPI
 */
export const IncoOperations = {
  /** Generate encrypted random number */
  E_RAND: "e_rand",
  /** Encrypted addition */
  E_ADD: "e_add",
  /** Encrypted subtraction */
  E_SUB: "e_sub",
  /** Encrypted multiplication */
  E_MUL: "e_mul",
  /** Encrypted division */
  E_DIV: "e_div",
  /** Encrypted modulo */
  E_MOD: "e_mod",
  /** Encrypted equality check */
  E_EQ: "e_eq",
  /** Encrypted less than */
  E_LT: "e_lt",
  /** Encrypted less than or equal */
  E_LE: "e_le",
  /** Encrypted greater than */
  E_GT: "e_gt",
  /** Encrypted greater than or equal */
  E_GE: "e_ge",
  /** Encrypted bitwise AND */
  E_AND: "e_and",
  /** Encrypted bitwise OR */
  E_OR: "e_or",
  /** Encrypted bitwise XOR */
  E_XOR: "e_xor",
  /** Encrypted conditional select (ternary) */
  E_SELECT: "e_select",
} as const;

export type IncoOperation = (typeof IncoOperations)[keyof typeof IncoOperations];

// ============================================================================
// DECRYPTION TYPES
// ============================================================================

/**
 * Result from attested decryption
 */
export interface DecryptionResult {
  /** Decrypted plaintext values */
  plaintexts: string[];
  /** Original encrypted handles */
  handles: string[];
  /** Ed25519 verification instructions for on-chain attestation */
  ed25519Instructions: unknown[];
  /** Raw covalidator signatures */
  signatures: string[];
}

/**
 * Options for decryption request
 */
export interface DecryptOptions {
  /** Wallet public key (base58 string or PublicKey) */
  address: PublicKey | string;
  /** Function to sign a message with the wallet */
  signMessage: (message: Uint8Array) => Promise<Uint8Array>;
}

// ============================================================================
// CONSTANTS
// ============================================================================

/**
 * Maximum handles per decryption batch (Solana transaction size limit)
 */
export const MAX_DECRYPT_HANDLES = 10;

/**
 * Covalidator endpoint for attested decryption
 */
export const ATTESTED_DECRYPT_ENDPOINT =
  "https://grpc.solana-devnet.alpha.devnet.inco.org/crypto/getDecryptAttested";

/**
 * Covalidator public key for signature verification
 */
export const COVALIDATOR_PUBLIC_KEY = "81owXEbskUpiLv3oNJN4cZxGr93U9MGH7Tt9AvYH2U4r";
