import { useCallback, useState } from "react";
import { useWallet } from "@solana/wallet-adapter-react";
import { decrypt, type AttestedDecryptResult } from "@inco/solana-sdk/attested-decrypt";
import { ENCRYPTION_CONSTANTS } from "@inco/solana-sdk/constants";
import { type Euint128, euint128ToHandle as convertEuint128ToHandle } from "./incoTypes";
import { INCO_LIGHTNING_PROGRAM_ID_STRING } from "./config";

/**
 * Result from decrypting an encrypted random number
 */
export interface DecryptedRandomResult {
  /** The decrypted random value as a bigint */
  value: bigint;
  /** The original encrypted handle */
  handle: string;
  /** Ed25519 instructions for on-chain verification (if needed) */
  ed25519Instructions: AttestedDecryptResult["ed25519Instructions"];
}

/**
 * Hook for working with Inco's encrypted random numbers on Solana
 *
 * ## How e_rand works:
 *
 * 1. Your Solana program calls `e_rand` via CPI to the Inco Lightning program
 * 2. Inco Lightning generates a secure encrypted random number (Euint128)
 * 3. The encrypted value is stored in your program's account
 * 4. Only authorized parties can decrypt it using `attestedDecrypt`
 *
 * ## On-chain (Rust) example:
 * ```rust
 * use inco_lightning::cpi::e_rand;
 * use inco_lightning::types::Euint128;
 *
 * let random_value: Euint128 = e_rand(cpi_ctx, 0)?;
 * ctx.accounts.table.random_seed = random_value;
 * ```
 *
 * ## Frontend (TypeScript) - decrypting:
 * ```typescript
 * const { decryptRandomValue } = useIncoRandom();
 * const result = await decryptRandomValue(handle);
 * console.log("Random number:", result.value);
 * ```
 */
export function useIncoRandom() {
  const { publicKey, signMessage } = useWallet();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  /**
   * Convert an Euint128 (encrypted u128) to a handle string for decryption
   * The handle is the hex representation of the u128 value
   */
  const euint128ToHandle = useCallback((euint: Euint128): string => {
    return convertEuint128ToHandle(euint);
  }, []);

  /**
   * Decrypt an encrypted random value generated by e_rand
   *
   * @param handle - The encrypted handle (hex string from Euint128)
   * @returns The decrypted random value and verification data
   *
   * @example
   * ```typescript
   * // After fetching table data with encrypted random seed
   * const tableData = await fetchTable(tableId);
   * const handle = euint128ToHandle(tableData.randomSeed);
   * const result = await decryptRandomValue(handle);
   * console.log("Decrypted random:", result.value);
   * ```
   */
  const decryptRandomValue = useCallback(
    async (handle: string): Promise<DecryptedRandomResult | null> => {
      if (!publicKey || !signMessage) {
        setError("Wallet not connected or does not support message signing");
        return null;
      }

      setIsLoading(true);
      setError(null);

      try {
        const result = await decrypt([handle], {
          address: publicKey,
          signMessage,
        });

        if (!result.plaintexts || result.plaintexts.length === 0) {
          throw new Error("No plaintext returned from decryption");
        }

        return {
          value: BigInt(result.plaintexts[0]),
          handle: result.handles[0],
          ed25519Instructions: result.ed25519Instructions,
        };
      } catch (err: any) {
        console.error("Failed to decrypt random value:", err);
        setError(err.message || "Failed to decrypt random value");
        return null;
      } finally {
        setIsLoading(false);
      }
    },
    [publicKey, signMessage]
  );

  /**
   * Decrypt multiple encrypted values in a single batch
   * More efficient than individual calls when you have multiple handles
   *
   * @param handles - Array of encrypted handles (max 10)
   * @returns Array of decrypted values
   */
  const decryptMultiple = useCallback(
    async (handles: string[]): Promise<DecryptedRandomResult[] | null> => {
      if (!publicKey || !signMessage) {
        setError("Wallet not connected or does not support message signing");
        return null;
      }

      if (handles.length > 10) {
        setError("Maximum 10 handles per batch (Solana transaction size limit)");
        return null;
      }

      setIsLoading(true);
      setError(null);

      try {
        const result = await decrypt(handles, {
          address: publicKey,
          signMessage,
        });

        return result.plaintexts.map((plaintext, i) => ({
          value: BigInt(plaintext),
          handle: result.handles[i],
          ed25519Instructions: result.ed25519Instructions,
        }));
      } catch (err: any) {
        console.error("Failed to decrypt values:", err);
        setError(err.message || "Failed to decrypt values");
        return null;
      } finally {
        setIsLoading(false);
      }
    },
    [publicKey, signMessage]
  );

  return {
    /** Convert Euint128 to decryption handle */
    euint128ToHandle,
    /** Decrypt a single encrypted random value */
    decryptRandomValue,
    /** Decrypt multiple encrypted values in batch */
    decryptMultiple,
    /** Loading state */
    isLoading,
    /** Error message if any */
    error,
    /** Inco constants for reference */
    constants: {
      INCO_LIGHTNING_PROGRAM_ID: INCO_LIGHTNING_PROGRAM_ID_STRING,
      COVALIDATOR_PUBLIC_KEY: ENCRYPTION_CONSTANTS.COVALIDATOR_PUBLIC_KEY,
      ATTESTED_DECRYPT_ENDPOINT: ENCRYPTION_CONSTANTS.ATTESTED_DECRYPT_ENDPOINT,
    },
  };
}
